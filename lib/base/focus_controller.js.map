{"version":3,"file":"focus_controller.js","sourceRoot":"","sources":["../../src/base/focus_controller.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAIH;;;;;;;;;;;;GAYG;AACH,MAAM,OAAO,eAAe;IAM1B,IAAI,oBAAoB;QACtB,OAAO,IAAI,CAAC,4BAA4B,IAAI,KAAK,CAAC;IACpD,CAAC;IAiBD,YACqB,IAAuC,EACvC,cAC0B;QAF1B,SAAI,GAAJ,IAAI,CAAmC;QACvC,mBAAc,GAAd,cAAc,CACY;QAlB9B,2BAAsB,GAAG,GAAG,EAAE;YAC7C,IAAI,IAAI,CAAC,4BAA4B,KAAK,KAAK,EAAE;gBAC/C,IAAI,CAAC,4BAA4B,GAAG,KAAK,CAAC;gBAC1C,IAAI,IAAI,CAAC,cAAc;oBAAE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;aACrD;QACH,CAAC,CAAC;QAEe,yBAAoB,GAAG,CAAC,EAAC,GAAG,EAAgB,EAAE,EAAE;YAC/D,IAAI,GAAG,KAAK,KAAK,IAAI,GAAG,KAAK,OAAO;gBAAE,OAAO;YAC7C,IAAI,IAAI,CAAC,4BAA4B,KAAK,IAAI,EAAE;gBAC9C,IAAI,CAAC,4BAA4B,GAAG,IAAI,CAAC;gBACzC,IAAI,IAAI,CAAC,cAAc;oBAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;aACpD;QACH,CAAC,CAAC;QAMA,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IAED,aAAa;QACX,QAAQ,CAAC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;QAChE,QAAQ,CAAC,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAAC;IACtE,CAAC;IAED,gBAAgB;QACd,QAAQ,CAAC,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;QACnE,QAAQ,CAAC,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAAC;IACzE,CAAC;CACF","sourcesContent":["/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\nimport {LitElement, ReactiveController, ReactiveControllerHost} from 'lit';\r\n\r\n/**\r\n * Controller to help customize focus behavior depending on if the user is\r\n * keyboard navigating with Tab and Enter.\r\n *\r\n * The controller's boolean property `isKeyboardNavigating` is flipped to true\r\n * when the user presses Tab or Enter, and flipped to false when they click the\r\n * mouse.\r\n *\r\n * The controller optionally accepts a callback that it calls whenever\r\n * `isKeyboardNavigating` changes. This can be used, for example, to toggle a\r\n * class in the host's shadow DOM to remove the default focus ring with CSS,\r\n * when it appears due to keypresses other than Tab/Enter.\r\n */\r\nexport class FocusController implements ReactiveController {\r\n  // Initialize the internal state to undefined so that the change callback is\r\n  // called on the first mousedown, even though externally the state is going\r\n  // from false to false.\r\n  private isKeyboardNavigatingInternal?: boolean;\r\n\r\n  get isKeyboardNavigating(): boolean {\r\n    return this.isKeyboardNavigatingInternal ?? false;\r\n  }\r\n\r\n  private readonly mousedownEventListener = () => {\r\n    if (this.isKeyboardNavigatingInternal !== false) {\r\n      this.isKeyboardNavigatingInternal = false;\r\n      if (this.changeCallback) this.changeCallback(false);\r\n    }\r\n  };\r\n\r\n  private readonly keydownEventListener = ({key}: KeyboardEvent) => {\r\n    if (key !== 'Tab' && key !== 'Enter') return;\r\n    if (this.isKeyboardNavigatingInternal !== true) {\r\n      this.isKeyboardNavigatingInternal = true;\r\n      if (this.changeCallback) this.changeCallback(true);\r\n    }\r\n  };\r\n\r\n  constructor(\r\n      private readonly host: ReactiveControllerHost&LitElement,\r\n      private readonly changeCallback?:\r\n          (isKeyboardNavigating: boolean) => void) {\r\n    this.host.addController(this);\r\n  }\r\n\r\n  hostConnected() {\r\n    document.addEventListener('keydown', this.keydownEventListener);\r\n    document.addEventListener('mousedown', this.mousedownEventListener);\r\n  }\r\n\r\n  hostDisconnected() {\r\n    document.removeEventListener('keydown', this.keydownEventListener);\r\n    document.removeEventListener('mousedown', this.mousedownEventListener);\r\n  }\r\n}\r\n"]}
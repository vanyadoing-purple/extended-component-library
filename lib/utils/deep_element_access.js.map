{"version":3,"file":"deep_element_access.js","sourceRoot":"","sources":["../../src/utils/deep_element_access.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH;;;;;;;;GAQG;AACH,MAAM,UAAU,oBAAoB;IAClC,IAAI,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC;IACrC,IAAI,CAAC,OAAO;QAAE,OAAO,IAAI,CAAC;IAC1B,IAAI,IAAI,CAAC;IACT,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,UAAU,EAAE,aAAa,CAAC,EAAE;QACjD,OAAO,GAAG,IAAI,CAAC;KAChB;IACD,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;GAGG;AACH,MAAM,SAAS,CAAC,CAAC,eAAe,CAAC,IAAU;IACzC,OAAO,IAAI,EAAE;QACX,MAAM,IAAI,CAAC;QACX,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC;SACxB;aAAM,IAAI,IAAI,YAAY,UAAU,EAAE;YACrC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;SAClB;aAAM;YACL,OAAO;SACR;KACF;AACH,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,YAAY,CACxB,QAA6B,EAAE,SAA8B;IAC/D,IAAI,CAAC,QAAQ,IAAI,CAAC,SAAS;QAAE,OAAO,KAAK,CAAC;IAC1C,KAAK,MAAM,IAAI,IAAI,eAAe,CAAC,SAAS,CAAC,EAAE;QAC7C,IAAI,IAAI,KAAK,QAAQ;YAAE,OAAO,IAAI,CAAC;KACpC;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,gBAAgB,CAC5B,SAAiB,EAAE,SAA8B;IACnD,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,CAAC,IAAI,CAAC,SAAS;QAAE,OAAO,KAAK,CAAC;IACzD,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC,CAAC;IACvC,KAAK,MAAM,IAAI,IAAI,eAAe,CAAC,SAAS,CAAC,EAAE;QAC7C,IAAI,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC;YAAE,OAAO,IAAI,CAAC;KACxC;IACD,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\n/**\r\n * Gets the active element, even if it's nested inside shadow DOMs.\r\n *\r\n * If the active element is in a shadow DOM, document.activeElement will be the\r\n * light DOM element whose shadow DOM contains it, so this is needed to find the\r\n * true active element.\r\n *\r\n * @return The active element, or `<body>` or null if there is none.\r\n */\r\nexport function getDeepActiveElement(): Element|null {\r\n  let current = document.activeElement;\r\n  if (!current) return null;\r\n  let next;\r\n  while ((next = current.shadowRoot?.activeElement)) {\r\n    current = next;\r\n  }\r\n  return current;\r\n}\r\n\r\n/**\r\n * Generator function that yields the chain of parent nodes upwards in the DOM\r\n * starting at `node`, and piercing shadow boundaries.\r\n */\r\nexport function* deepParentChain(node: Node) {\r\n  while (true) {\r\n    yield node;\r\n    if (node.parentNode) {\r\n      node = node.parentNode;\r\n    } else if (node instanceof ShadowRoot) {\r\n      node = node.host;\r\n    } else {\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Behaves like Node.contains() but accounts for shadow descendants as well.\r\n *\r\n * @param rootNode - A node that might be the ancestor.\r\n * @param otherNode - A node that might be the descendant.\r\n * @return true if otherNode is a light or shadow descendant of rootNode.\r\n */\r\nexport function deepContains(\r\n    rootNode: Node|null|undefined, otherNode: Node|null|undefined): boolean {\r\n  if (!rootNode || !otherNode) return false;\r\n  for (const node of deepParentChain(otherNode)) {\r\n    if (node === rootNode) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns true if for some node in rootNodes, otherNode is a light or shadow\r\n * descendant of the node. Uses a single search in\r\n * O(|rootNodes| + (depth of otherNode)).\r\n */\r\nexport function someDeepContains(\r\n    rootNodes: Node[], otherNode: Node|null|undefined): boolean {\r\n  if ((rootNodes.length === 0) || !otherNode) return false;\r\n  const rootNodeSet = new Set(rootNodes);\r\n  for (const node of deepParentChain(otherNode)) {\r\n    if (rootNodeSet.has(node)) return true;\r\n  }\r\n  return false;\r\n}\r\n"]}
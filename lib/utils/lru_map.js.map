{"version":3,"file":"lru_map.js","sourceRoot":"","sources":["../../src/utils/lru_map.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH;;;GAGG;AACH,MAAM,OAAO,MAAM;IAGjB;;;;OAIG;IACH,YAA6B,QAAgB;QAAhB,aAAQ,GAAR,QAAQ,CAAQ;QAP5B,QAAG,GAAG,IAAI,GAAG,EAAQ,CAAC;IAOS,CAAC;IAEjD,GAAG,CAAC,GAAM;QACR,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC;QAC5B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC3B,CAAC;IAED,GAAG,CAAC,GAAM;QACR,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC;QAC5B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC3B,CAAC;IAED,GAAG,CAAC,GAAM,EAAE,KAAQ;QAClB,4EAA4E;QAC5E,qBAAqB;QACrB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACjB,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QACzB,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE;YACjC,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;YACjC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;SACzB;IACH,CAAC;IAED,MAAM,CAAC,GAAM;QACX,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YACrB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SACtB;IACH,CAAC;IAED;;;;OAIG;IACK,iBAAiB,CAAC,GAAM;QAC9B,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YACrB,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC;YACjC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YACrB,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;SAC1B;IACH,CAAC;CACF","sourcesContent":["/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\n/**\r\n * A limited-capacity map with a least-recently-used eviction policy. Includes\r\n * the operations `get`, `set`, and `has`, which behave the same as on a `Map`.\r\n */\r\nexport class LRUMap<K, V> {\r\n  private readonly map = new Map<K, V>();\r\n\r\n  /**\r\n   * @param capacity - The maximum number of entries allowed in the map. When\r\n   *     inserting a new entry beyond this limit, the least recently used entry\r\n   *     will be evicted.\r\n   */\r\n  constructor(private readonly capacity: number) {}\r\n\r\n  has(key: K): boolean {\r\n    this.reinsertIfPresent(key);\r\n    return this.map.has(key);\r\n  }\r\n\r\n  get(key: K): V|undefined {\r\n    this.reinsertIfPresent(key);\r\n    return this.map.get(key);\r\n  }\r\n\r\n  set(key: K, value: V) {\r\n    // Rather than reinserting the entry, just delete it to avoid the extra call\r\n    // to this.map.set().\r\n    this.delete(key);\r\n    this.map.set(key, value);\r\n    if (this.map.size > this.capacity) {\r\n      const [lruKey] = this.map.keys();\r\n      this.map.delete(lruKey);\r\n    }\r\n  }\r\n\r\n  delete(key: K) {\r\n    if (this.map.has(key)) {\r\n      this.map.delete(key);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reinserts the entry with the given key if it exists. This is used to\r\n   * implement the LRU policy: the native `Map` is ordered by insertion order,\r\n   * so the reinsertion keeps it ordered by access time.\r\n   */\r\n  private reinsertIfPresent(key: K) {\r\n    if (this.map.has(key)) {\r\n      const value = this.map.get(key)!;\r\n      this.map.delete(key);\r\n      this.map.set(key, value);\r\n    }\r\n  }\r\n}\r\n"]}
{"version":3,"file":"request_cache.js","sourceRoot":"","sources":["../../src/utils/request_cache.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,MAAM,EAAC,MAAM,cAAc,CAAC;AAEpC;;GAEG;AACH,MAAM,OAAO,YAAY;IAEvB;;;;OAIG;IACH,YACI,QAAgB,EACC,WAA0C;QAA1C,gBAAW,GAAX,WAAW,CAA+B;QAC7D,IAAI,CAAC,eAAe,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC;IAC9C,CAAC;IAED;;OAEG;IACH,GAAG,CAAC,OAAoB;QACtB,OAAO,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,IAAI,IAAI,CAAC;IACnE,CAAC;IAED;;;OAGG;IACH,GAAG,CAAC,GAAgB,EAAE,KAA4B;QAChD,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;QAC1C,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,aAAa,EAAE,KAAK,CAAC,CAAC;QAC/C,KAAK,CAAC,KAAK,CAAC,CAAC,KAAgB,EAAE,EAAE;YAC/B,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;gBAC3B,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;aAC5C;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACK,SAAS,CAAC,OAAoB;QAKpC,oEAAoE;QACpE,sEAAsE;QACtE,2CAA2C;QAC3C,MAAM,QAAQ,GAAG,CAAC,GAAW,EAAE,KAAc,EAAE,EAAE;YAC/C,IAAI,KAAK,YAAY,MAAM,IAAI,CAAC,CAAC,KAAK,YAAY,KAAK,CAAC,EAAE;gBACxD,MAAM,GAAG,GAAG,KAAsB,CAAC;gBACnC,MAAM,MAAM,GAAkB,EAAE,CAAC;gBACjC,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;oBACzC,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;iBACxB;gBACD,OAAO,MAAM,CAAC;aACf;iBAAM;gBACL,OAAO,KAAK,CAAC;aACd;QACH,CAAC,CAAC;QACF,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAC3C,CAAC;CACF","sourcesContent":["/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\nimport {LRUMap} from './lru_map.js';\r\n\r\n/**\r\n * A limited-capacity cache keyed by serialized request objects.\r\n */\r\nexport class RequestCache<RequestType, ResponseType, ErrorType extends Error> {\r\n  private readonly requestCacheMap: LRUMap<string, Promise<ResponseType>>;\r\n  /**\r\n   * @param capacity - The maximum number of objects to keep in the cache.\r\n   * @param shouldRetry - Callback that determines if a request should be\r\n   * retried, or if the failure should be cached.\r\n   */\r\n  constructor(\r\n      capacity: number,\r\n      private readonly shouldRetry: (error: ErrorType) => boolean) {\r\n    this.requestCacheMap = new LRUMap(capacity);\r\n  }\r\n\r\n  /**\r\n   * Gets the cached result with the given request\r\n   */\r\n  get(request: RequestType): Promise<ResponseType>|null {\r\n    return this.requestCacheMap.get(this.serialize(request)) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Adds the provided request to the cache, replacing the\r\n   * existing result if one exists already.\r\n   */\r\n  set(key: RequestType, value: Promise<ResponseType>) {\r\n    const serializedKey = this.serialize(key);\r\n    this.requestCacheMap.set(serializedKey, value);\r\n    value.catch((error: ErrorType) => {\r\n      if (this.shouldRetry(error)) {\r\n        this.requestCacheMap.delete(serializedKey);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deterministically serializes arbitrary objects to strings.\r\n   */\r\n  private serialize(request: RequestType): string {\r\n    interface UnknownObject {\r\n      [key: string]: unknown;\r\n    }\r\n\r\n    // Non-numeric keys in modern JS are iterated in order of insertion.\r\n    // Make a new object and insert the keys in alphabetical order so that\r\n    // the object is serialized alphabetically.\r\n    const replacer = (key: string, value: unknown) => {\r\n      if (value instanceof Object && !(value instanceof Array)) {\r\n        const obj = value as UnknownObject;\r\n        const sorted: UnknownObject = {};\r\n        for (const key of Object.keys(obj).sort()) {\r\n          sorted[key] = obj[key];\r\n        }\r\n        return sorted;\r\n      } else {\r\n        return value;\r\n      }\r\n    };\r\n    return JSON.stringify(request, replacer);\r\n  }\r\n}"]}
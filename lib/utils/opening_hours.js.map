{"version":3,"file":"opening_hours.js","sourceRoot":"","sources":["../../src/utils/opening_hours.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\nimport type {Place} from './googlemaps_types.js';\r\n\r\nconst ONE_DAY_IN_MS = 24 * 60 * 60 * 1000;\r\nconst ONE_WEEK_IN_MS = 7 * ONE_DAY_IN_MS;\r\n\r\ntype OpeningHours = google.maps.places.OpeningHours;\r\ntype OpeningHoursPeriod = google.maps.places.OpeningHoursPeriod;\r\ntype OpeningHoursPoint = google.maps.places.OpeningHoursPoint;\r\n\r\n/**\r\n * Formats a relative point in time according to the browser's locale format.\r\n */\r\nfunction formatPointTime(\r\n    point: OpeningHoursPoint, includeWeekday = false): string {\r\n  // Choose an arbitrary `Date`, then set the fields needed for formatting\r\n  // (weekday and time).\r\n  const date = new Date();\r\n  date.setDate(date.getDate() - date.getDay() + point.day);\r\n  date.setHours(point.hour);\r\n  date.setMinutes(point.minute);\r\n  date.setSeconds(0);\r\n\r\n  return date.toLocaleString(\r\n      /* locales= */ undefined, {\r\n        hour: 'numeric',\r\n        minute: 'numeric',\r\n        weekday: includeWeekday ? 'short' : undefined\r\n      });\r\n}\r\n\r\n/**\r\n * Formats a relative point in time (specified in the Place's TZ), usually\r\n * including the weekday. However, if the point in time, as an absolute\r\n * timestamp, occurs within the next 24 hours, hide the weekday.\r\n *\r\n * @param point The relative time from the Places API (weekday, hour, minute)\r\n * @param absolutePoint The instant in time corresponding to `point`, i.e. a\r\n *     `Date` object\r\n * @param now Used to determine if `absolutePoint` is coming soon\r\n */\r\nexport function formatTimeWithWeekdayMaybe(\r\n    point: OpeningHoursPoint, absolutePoint: Date, now = new Date()): string {\r\n  return formatPointTime(point, !isSoon(absolutePoint, now));\r\n}\r\n\r\n/**\r\n * Returns whether the given date is in the future and soon approaching. \"Soon\"\r\n * means sooner than the `intervalMs` argument (default 24 hours).\r\n */\r\nexport function isSoon(\r\n    date: Date, now = new Date(), intervalMs = ONE_DAY_IN_MS): boolean {\r\n  return ((date >= now) && ((date.valueOf() - now.valueOf()) < intervalMs));\r\n}\r\n\r\n/** Detects if a Place is declared as always open. */\r\nfunction isPlaceAlwaysOpen(openingHours: OpeningHours): boolean {\r\n  return (\r\n      (openingHours.periods?.length === 1) && !openingHours.periods[0].close &&\r\n      (openingHours.periods[0].open.day === 0) &&\r\n      (openingHours.periods[0].open.hour === 0) &&\r\n      (openingHours.periods[0].open.minute === 0));\r\n}\r\n\r\n/** Gets the date components of the most recent Sunday (relative to UTC). */\r\nfunction getLastSundayUTC(date: Date):\r\n    {year: number, month: number, day: number} {\r\n  const sundayUTC = new Date(date);\r\n  sundayUTC.setUTCDate(sundayUTC.getUTCDate() - sundayUTC.getUTCDay());\r\n  return {\r\n    year: sundayUTC.getUTCFullYear(),\r\n    month: sundayUTC.getUTCMonth(),\r\n    day: sundayUTC.getUTCDate(),\r\n  };\r\n}\r\n\r\n/**\r\n * From all occurrences of \"Sunday at 00:00\" in the Place's timezone, return\r\n * the most recent one prior to `now`.\r\n */\r\nfunction getLastSundayInPlaceTimezone(\r\n    now: Date, utcOffsetMinutes: number): Date {\r\n  const {year, month, day} = getLastSundayUTC(now);\r\n  let placeSundayStart = Date.UTC(year, month, day, 0, -utcOffsetMinutes);\r\n\r\n  // Because of the offset, `placeSundayStart` could be after `now` or more\r\n  // than 7 days before it. Increment as necessary.\r\n  const deltaBeforeNowMs = now.valueOf() - placeSundayStart;\r\n  if (deltaBeforeNowMs < 0) {\r\n    placeSundayStart -= ONE_WEEK_IN_MS;\r\n  } else if (deltaBeforeNowMs >= ONE_WEEK_IN_MS) {\r\n    placeSundayStart += ONE_WEEK_IN_MS;\r\n  }\r\n  return new Date(placeSundayStart);\r\n}\r\n\r\n/**\r\n * Converts a relative `OpeningHoursPoint` object into an absolute timestamp,\r\n * indexed off of `placeSundayStart`.\r\n */\r\nfunction getPointDate(point: OpeningHoursPoint, placeSundayStart: Date): Date {\r\n  const pointDate = new Date(placeSundayStart);\r\n  pointDate.setDate(pointDate.getDate() + point.day);\r\n  pointDate.setHours(pointDate.getHours() + point.hour);\r\n  pointDate.setMinutes(pointDate.getMinutes() + point.minute);\r\n  return pointDate;\r\n}\r\n\r\n/**\r\n * Finds the currently active Opening Hours Period, if any, along with its\r\n * absolute open and closing timestamps.\r\n */\r\nfunction getCurrentPeriod(\r\n    openingHours: OpeningHours, utcOffsetMinutes: number, now = new Date()):\r\n    {period?: OpeningHoursPeriod, openDate?: Date, closeDate?: Date} {\r\n  const lastSundayStart = getLastSundayInPlaceTimezone(now, utcOffsetMinutes);\r\n\r\n  for (const period of openingHours.periods) {\r\n    const stats = {\r\n      period,\r\n      openDate: getPointDate(period.open, lastSundayStart),\r\n      closeDate: period.close ? getPointDate(period.close, lastSundayStart) :\r\n                                undefined\r\n    };\r\n    if (!stats.closeDate) {\r\n      return stats;\r\n    }\r\n\r\n    // In situations where the local close time appears earlier than the open\r\n    // time, e.g. \"Opens Saturday (6), closes Sunday (0)\", create a forward\r\n    // interval.\r\n    if (stats.closeDate < stats.openDate) {\r\n      if (stats.openDate > now) {\r\n        stats.openDate.setDate(stats.openDate.getDate() - 7);\r\n      } else {\r\n        stats.closeDate.setDate(stats.closeDate.getDate() + 7);\r\n      }\r\n    }\r\n\r\n    if ((now >= stats.openDate) && (now < stats.closeDate)) {\r\n      return stats;\r\n    }\r\n  }\r\n  return {};\r\n}\r\n\r\n/** Status indicator for an upcoming close time. */\r\nexport enum NextCloseTimeStatus {\r\n  UNKNOWN,\r\n  ALWAYS_OPEN,\r\n  NOT_OPEN_NOW,\r\n  WILL_CLOSE\r\n}\r\n\r\ninterface UpcomingCloseTimeResult {\r\n  status: NextCloseTimeStatus;\r\n  closePoint?: OpeningHoursPoint;\r\n  closeDate?: Date;\r\n}\r\n\r\n/**\r\n * Finds the next closing time of a Place, returning it (if present) and a\r\n * status flag.\r\n *\r\n * Does not take into account exceptional hours (such as holidays) or business\r\n * status.\r\n */\r\nexport function getUpcomingCloseTime(\r\n    place: Place, now = new Date()): UpcomingCloseTimeResult {\r\n  if (!place.regularOpeningHours || place.utcOffsetMinutes == null) {\r\n    return {status: NextCloseTimeStatus.UNKNOWN};\r\n  } else if (isPlaceAlwaysOpen(place.regularOpeningHours)) {\r\n    return {status: NextCloseTimeStatus.ALWAYS_OPEN};\r\n  }\r\n\r\n  const currentPeriod =\r\n      getCurrentPeriod(place.regularOpeningHours, place.utcOffsetMinutes, now);\r\n  if (!currentPeriod.period) {\r\n    return {status: NextCloseTimeStatus.NOT_OPEN_NOW};\r\n  } else if (!currentPeriod.closeDate) {\r\n    // This should not happen unless we receive malformed data; \"always open\"\r\n    // should be caught by the `isPlaceAlwaysOpen()` check above.\r\n    return {status: NextCloseTimeStatus.ALWAYS_OPEN};\r\n  }\r\n\r\n  return {\r\n    status: NextCloseTimeStatus.WILL_CLOSE,\r\n    closeDate: currentPeriod.closeDate,\r\n\r\n    // Always defined if `currentPeriod.closeDate` is\r\n    closePoint: currentPeriod.period.close!,\r\n  };\r\n}\r\n\r\n/** Status indicator for an upcoming opening time. */\r\nexport enum NextOpenTimeStatus {\r\n  UNKNOWN,\r\n  NEVER_OPEN,\r\n  ALREADY_OPEN,\r\n  WILL_OPEN\r\n}\r\n\r\ninterface UpcomingOpenTimeResult {\r\n  status: NextOpenTimeStatus;\r\n  openPoint?: OpeningHoursPoint;\r\n  openDate?: Date;\r\n}\r\n\r\n/**\r\n * Finds the next open time of a Place, returning it (if present) and a\r\n * status flag.\r\n *\r\n * Does not take into account exceptional hours (such as holidays) or business\r\n * status.\r\n */\r\nexport function getUpcomingOpenTime(\r\n    place: Place, now = new Date()): UpcomingOpenTimeResult {\r\n  if (!place.regularOpeningHours || place.utcOffsetMinutes == null) {\r\n    return {status: NextOpenTimeStatus.UNKNOWN};\r\n  } else if (isPlaceAlwaysOpen(place.regularOpeningHours)) {\r\n    return {status: NextOpenTimeStatus.ALREADY_OPEN};\r\n  }\r\n\r\n  const lastSundayStart =\r\n      getLastSundayInPlaceTimezone(now, place.utcOffsetMinutes);\r\n  const bestResult: UpcomingOpenTimeResult = {\r\n    status: NextOpenTimeStatus.NEVER_OPEN,\r\n  };\r\n  let closestOpenInterval = Infinity;\r\n  for (const period of place.regularOpeningHours.periods) {\r\n    const openDate = getPointDate(period.open, lastSundayStart);\r\n    if (!period.close) {\r\n      return {status: NextOpenTimeStatus.ALREADY_OPEN};\r\n    }\r\n    const closeDate = getPointDate(period.close, lastSundayStart);\r\n    if ((closeDate >= openDate) && (now >= openDate) && (now < closeDate)) {\r\n      return {status: NextOpenTimeStatus.ALREADY_OPEN};\r\n    } else if (\r\n        (closeDate < openDate) && !((now >= closeDate) && (now < openDate))) {\r\n      return {status: NextOpenTimeStatus.ALREADY_OPEN};\r\n    }\r\n\r\n    // Make sure openDate is in the future\r\n    if (openDate < now) {\r\n      openDate.setDate(openDate.getDate() + 7);\r\n    }\r\n    const interval = openDate.valueOf() - now.valueOf();\r\n    if (interval < closestOpenInterval) {\r\n      closestOpenInterval = interval;\r\n      bestResult.status = NextOpenTimeStatus.WILL_OPEN;\r\n      bestResult.openPoint = period.open;\r\n      bestResult.openDate = openDate;\r\n    }\r\n  }\r\n  return bestResult;\r\n}\r\n\r\n/**\r\n * Temporary (until Place is GA) replacement for the built-in isOpen() method.\r\n */\r\nexport function isOpen(place: Place, now = new Date()): boolean|undefined {\r\n  if (!place.regularOpeningHours || place.utcOffsetMinutes == null) {\r\n    return undefined;\r\n  } else if (isPlaceAlwaysOpen(place.regularOpeningHours)) {\r\n    return true;\r\n  }\r\n  const {period} =\r\n      getCurrentPeriod(place.regularOpeningHours, place.utcOffsetMinutes, now);\r\n  return !!period;\r\n}"]}
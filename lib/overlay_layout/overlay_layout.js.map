{"version":3,"file":"overlay_layout.js","sourceRoot":"","sources":["../../src/overlay_layout/overlay_layout.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\nimport {css, CSSResultGroup, html} from 'lit';\r\nimport {customElement, query, queryAssignedElements, state} from 'lit/decorators.js';\r\nimport {styleMap} from 'lit/directives/style-map.js';\r\n\r\nimport {BaseComponent} from '../base/base_component.js';\r\nimport {SlotValidationController} from '../base/slot_validation_controller.js';\r\nimport {getDeepActiveElement, someDeepContains} from '../utils/deep_element_access.js';\r\n\r\n/**\r\n * The overlay layout component allows you to display information in a\r\n * responsive panel view that sits on top of main content, like a map or a list.\r\n * You might use this to show a modal dialog, more details about a place, or\r\n * settings.\r\n *\r\n * This component helps manage keyboard focus when opening and closing the\r\n * overlay.\r\n *\r\n * The size of the gmpx-overlay-layout can be set directly with the `width` and\r\n * `height` properties. If none are provided, it will fill the size of its\r\n * containing element.\r\n *\r\n * ![](./doc_src/overlay-layout.gif)\r\n *\r\n * **To use this component, you'll need to specify `slot=\"main\"` or\r\n * `slot=\"overlay\"` on its children.** Read more on using slots\r\n * [here](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_templates_and_slots#adding_flexibility_with_slots).\r\n *\r\n * @slot main - Main content, displayed by default.\r\n * @slot overlay - Overlay content that replaces the main content when the panel\r\n * is opened.\r\n */\r\n@customElement('gmpx-overlay-layout')\r\nexport class OverlayLayout extends BaseComponent {\r\n  static override styles: CSSResultGroup = css`\r\n    :host(:not([hidden])) {\r\n      display: block;\r\n      height: 100%;\r\n    }\r\n    .outer-container {\r\n      display: block;\r\n      height: 100%;\r\n      position: relative;\r\n    }\r\n    .inner-container {\r\n      inset: 0;\r\n      overflow: auto;\r\n      position: absolute;\r\n    }\r\n    .inner-container:focus-visible {\r\n      outline: none;\r\n    }\r\n  `;\r\n\r\n  @queryAssignedElements({slot: 'main'})\r\n  private readonly mainAssignedEls!: HTMLElement[];\r\n\r\n  @queryAssignedElements({slot: 'overlay'})\r\n  private readonly overlayAssignedEls!: HTMLElement[];\r\n\r\n  @query('.main-container') private readonly mainContainer!: HTMLDivElement;\r\n\r\n  @query('.overlay-container')\r\n  private readonly overlayContainer!: HTMLDivElement;\r\n\r\n  @state() private opened = false;\r\n  private mainLastActiveEl: HTMLElement|null = null;\r\n\r\n  protected slotValidator =\r\n      new SlotValidationController(this, this.logger, ['main', 'overlay']);\r\n\r\n  /**\r\n   * Opens the overlay panel.\r\n   *\r\n   * If focus is currently in the main content, the focused element will be\r\n   * saved to regain focus when closing the overlay. Focus will then move to\r\n   * the element in the overlay slot with autofocus, if present. If no element\r\n   * has autofocus, the internal overlay container will be focused so that\r\n   * pressing Tab will focus the first interactive element in the overlay slot.\r\n   *\r\n   * Overlay content will be scrolled to the top, if the panel was previously\r\n   * opened and scrolled down.\r\n   */\r\n  async showOverlay() {\r\n    if (this.opened) return;\r\n    this.mainLastActiveEl = this.getMainActiveEl();\r\n    this.opened = true;\r\n    await this.updateComplete;\r\n    this.overlayContainer.scroll(0, 0);\r\n    if (this.mainLastActiveEl) {\r\n      const autofocusEl = this.getOverlayAutofocusEl();\r\n      if (autofocusEl) {\r\n        autofocusEl.focus();\r\n      } else {\r\n        this.overlayContainer.focus();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Closes the overlay panel.\r\n   *\r\n   * If focus is currently in the overlay content, focus will move to the last\r\n   * focused main element, if this was saved when opening the panel. If no\r\n   * focused element was saved, the internal main container will be focused\r\n   * so that pressing Tab will focus the first interactive element in the main\r\n   * slot.\r\n   */\r\n  async hideOverlay() {\r\n    if (!this.opened) return;\r\n    const overlayActiveEl = this.getOverlayActiveEl();\r\n    this.opened = false;\r\n    if (overlayActiveEl || (getDeepActiveElement() === this.overlayContainer)) {\r\n      await this.updateComplete;\r\n      if (this.mainLastActiveEl) {\r\n        this.mainLastActiveEl.focus();\r\n      } else {\r\n        this.mainContainer.focus();\r\n      }\r\n    }\r\n    this.mainLastActiveEl = null;\r\n  }\r\n\r\n  protected override render() {\r\n    // clang-format off\r\n    return html`\r\n      <div class=\"outer-container\">\r\n        <div\r\n          class=\"inner-container main-container\"\r\n          style=${styleMap({'display': this.opened ? 'none' : 'block'})}\r\n          tabindex=\"-1\"\r\n        >\r\n          <slot name=\"main\"></slot>\r\n        </div>\r\n        <div\r\n          class=\"inner-container overlay-container\"\r\n          style=${styleMap({'display': this.opened ? 'block' : 'none'})}\r\n          tabindex=\"-1\"\r\n          @keydown=${this.handleOverlayKeydown}\r\n        >\r\n          <slot name=\"overlay\"></slot>\r\n        </div>\r\n      </div>\r\n    `;\r\n    // clang-format on\r\n  }\r\n\r\n  private handleOverlayKeydown(e: KeyboardEvent) {\r\n    if (e.key === 'Escape') {\r\n      this.hideOverlay();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the active element if it's a descendant, even across shadow\r\n   * boundaries, of one of the elements in els.\r\n   */\r\n  private getContainedActiveEl(els: Element[]): HTMLElement|null {\r\n    const deepActiveEl = getDeepActiveElement();\r\n    if (deepActiveEl instanceof HTMLElement) {\r\n      if (someDeepContains(els, deepActiveEl)) return deepActiveEl;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private getMainActiveEl(): HTMLElement|null {\r\n    return this.getContainedActiveEl(this.mainAssignedEls);\r\n  }\r\n\r\n  private getOverlayActiveEl(): HTMLElement|null {\r\n    return this.getContainedActiveEl(this.overlayAssignedEls);\r\n  }\r\n\r\n  private getOverlayAutofocusEl(): HTMLElement|null {\r\n    for (const el of this.overlayAssignedEls) {\r\n      const autofocusEl = el.querySelector('[autofocus]');\r\n      if (autofocusEl && autofocusEl instanceof HTMLElement) {\r\n        return autofocusEl;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\ndeclare global {\r\n  interface HTMLElementTagNameMap {\r\n    'gmpx-overlay-layout': OverlayLayout;\r\n  }\r\n}\r\n"]}
{"version":3,"file":"viewport_manager.js","sourceRoot":"","sources":["../../src/route_building_blocks/viewport_manager.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,SAAS,EAAC,MAAM,6BAA6B,CAAC;AAiBtD;;;GAGG;AACH,MAAM,OAAO,eAAe;IAC1B,YAAqB,GAAe;QAAf,QAAG,GAAH,GAAG,CAAY;QAgBnB,sBAAiB,GAAG,IAAI,GAAG,EAAiB,CAAC;IAhBvB,CAAC;IAIxC;;;;OAIG;IACH,MAAM,CAAC,iBAAiB,CAAC,GAAe;QACtC,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YACvC,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC;SAC9D;QACD,OAAO,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC;IAC7C,CAAC;IAID;;;OAGG;IACH,KAAK,CAAC,QAAQ,CAAC,SAAwB;QACrC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;YAC1C,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YACtC,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;SAC7B;IACH,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,UAAU,CAAC,SAAwB;QACvC,IAAI,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;YACzC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACzC,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;SAC7B;IACH,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,cAAc;QAClB,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;QAChD,IAAI,WAAW,EAAE;YACf,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;SAC1C;IACH,CAAC;IAEO,KAAK,CAAC,cAAc;QAC1B,IAAI,MAAM,GAAsB,IAAI,CAAC;QACrC,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC9C,MAAM,MAAM,GAAG,SAAS,CAAC,SAAS,EAAE,CAAC;YACrC,IAAI,MAAM,EAAE;gBACV,IAAI,CAAC,MAAM,EAAE;oBACX,MAAM,EAAC,YAAY,EAAC,GAChB,MAAM,SAAS,CAAC,aAAa,CAAC,MAAM,CAAuB,CAAC;oBAChE,MAAM,GAAG,IAAI,YAAY,EAAE,CAAC;iBAC7B;gBACD,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;aACtB;SACF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;;AA/DuB,yBAAS,GAAG,IAAI,GAAG,EAA+B,AAAzC,CAA0C","sourcesContent":["/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\nimport {APILoader} from '../api_loader/api_loader.js';\r\nimport {MapElement} from '../utils/googlemaps_types.js';\r\n\r\ntype LatLngBounds = google.maps.LatLngBounds;\r\n\r\n/**\r\n * Interface for components that occupy an area on the map in LatLng space, and\r\n * can be managed by the `ViewportManager`.\r\n */\r\nexport interface LatLngBounded {\r\n  /**\r\n   * Returns the `LatLngBounds` of the component that should be included in the\r\n   * map's viewport, or `null` if the component should be ignored.\r\n   */\r\n  getBounds(): google.maps.LatLngBounds|google.maps.LatLngBoundsLiteral|null;\r\n}\r\n\r\n/**\r\n * Manages a map's viewport to fit the bounds of one or several `LatLngBounded`\r\n * components.\r\n */\r\nexport class ViewportManager {\r\n  constructor(readonly map: MapElement) {}\r\n\r\n  private static readonly instances = new Map<MapElement, ViewportManager>();\r\n\r\n  /**\r\n   * Returns the `ViewportManager` instance for the given `MapElement`,\r\n   * constructing one if none exists already. Each `MapElement` will have only\r\n   * one associated `ViewportManager` instance.\r\n   */\r\n  static getInstanceForMap(map: MapElement) {\r\n    if (!ViewportManager.instances.has(map)) {\r\n      ViewportManager.instances.set(map, new ViewportManager(map));\r\n    }\r\n    return ViewportManager.instances.get(map)!;\r\n  }\r\n\r\n  private readonly managedComponents = new Set<LatLngBounded>();\r\n\r\n  /**\r\n   * Registers a `LatLngBounded` component to be included in the viewport.\r\n   * Triggers an `updateViewport()` if the component was not already registered.\r\n   */\r\n  async register(component: LatLngBounded) {\r\n    if (!this.managedComponents.has(component)) {\r\n      this.managedComponents.add(component);\r\n      await this.updateViewport();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If the given `LatLngBounded` component is registered, unregisters it and\r\n   * triggers an `updateViewport()`.\r\n   */\r\n  async unregister(component: LatLngBounded) {\r\n    if (this.managedComponents.has(component)) {\r\n      this.managedComponents.delete(component);\r\n      await this.updateViewport();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the map's viewport to fit all registered `LatLngBounded`\r\n   * components.\r\n   */\r\n  async updateViewport() {\r\n    const boundsUnion = await this.getBoundsUnion();\r\n    if (boundsUnion) {\r\n      this.map.innerMap.fitBounds(boundsUnion);\r\n    }\r\n  }\r\n\r\n  private async getBoundsUnion(): Promise<LatLngBounds|null> {\r\n    let result: LatLngBounds|null = null;\r\n    for (const component of this.managedComponents) {\r\n      const bounds = component.getBounds();\r\n      if (bounds) {\r\n        if (!result) {\r\n          const {LatLngBounds} =\r\n              await APILoader.importLibrary('core') as typeof google.maps;\r\n          result = new LatLngBounds();\r\n        }\r\n        result.union(bounds);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n}\r\n"]}
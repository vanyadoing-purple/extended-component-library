{"version":3,"file":"cached_place_lookup.js","sourceRoot":"","sources":["../../../src/place_building_blocks/place_data_provider/cached_place_lookup.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,SAAS,EAAC,MAAM,gCAAgC,CAAC;AAEzD,OAAO,EAAC,MAAM,EAAC,MAAM,wBAAwB,CAAC;AAG9C;;;;GAIG;AACH,KAAK,UAAU,mBAAmB,CAC9B,EAAU,EAAE,QAAsB;IACpC,MAAM,EAAC,KAAK,EAAC,GAAG,MAAM,SAAS,CAAC,aAAa,CAAC,QAAQ,EAAE,QAAQ,CACnC,CAAC;IAC9B,OAAO,IAAI,KAAK,CAAC,EAAC,EAAE,EAAC,CAAU,CAAC;AAClC,CAAC;AAED;;;GAGG;AACH,MAAM,OAAO,iBAAiB;IAG5B;;;;;;OAMG;IACH,YAAY,QAAgB,EAAmB,QAAsB;QAAtB,aAAQ,GAAR,QAAQ,CAAc;QACnE,IAAI,CAAC,KAAK,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC;IACpC,CAAC;IAED;;;;;;OAMG;IACH,QAAQ,CAAC,EAAU;QACjB,MAAM,kBAAkB,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAC9C,IAAI,kBAAkB;YAAE,OAAO,kBAAkB,CAAC;QAElD,MAAM,eAAe,GAAG,mBAAmB,CAAC,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC/D,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE,eAAe,CAAC,CAAC;QACpC,OAAO,eAAe,CAAC;IACzB,CAAC;IAED;;;OAGG;IACH,WAAW,CAAC,KAAY;QACtB,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,EAAE,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;IACnD,CAAC;CACF","sourcesContent":["/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\nimport {APILoader} from '../../api_loader/api_loader.js';\r\nimport type {Place} from '../../utils/googlemaps_types.js';\r\nimport {LRUMap} from '../../utils/lru_map.js';\r\n\r\n\r\n/**\r\n * Makes a promise that will resolve to a new `Place` with the given ID, or\r\n * reject with an error if the `Place` constructor throws one. This must be done\r\n * asynchronously due to the loading of the `Place` constructor from the API.\r\n */\r\nasync function makeNewPlacePromise(\r\n    id: string, consumer?: HTMLElement): Promise<Place> {\r\n  const {Place} = await APILoader.importLibrary('places', consumer) as\r\n      typeof google.maps.places;\r\n  return new Place({id}) as Place;\r\n}\r\n\r\n/**\r\n * A limited-capacity cache of `Place` objects keyed by place ID. Creates new\r\n * `Place` objects as needed when they do not exist already.\r\n */\r\nexport class CachedPlaceLookup {\r\n  private readonly cache: LRUMap<string, Promise<Place>>;\r\n\r\n  /**\r\n   * @param capacity - The maximum number of `Place` objects to keep in the\r\n   *     cache.\r\n   * @param consumer - Optionally specify the custom element using the cached\r\n   *     place lookup, to provide more helpful console warnings when the places\r\n   *     library cannot be loaded.\r\n   */\r\n  constructor(capacity: number, private readonly consumer?: HTMLElement) {\r\n    this.cache = new LRUMap(capacity);\r\n  }\r\n\r\n  /**\r\n   * Gets the cached `Place` with the given ID. If none exists, a new `Place`\r\n   * will be created, cached, and returned.\r\n   *\r\n   * Note: The returned promise will be rejected with an error from the `Place`\r\n   * constructor if `id` is an empty string.\r\n   */\r\n  getPlace(id: string): Promise<Place> {\r\n    const cachedPlacePromise = this.cache.get(id);\r\n    if (cachedPlacePromise) return cachedPlacePromise;\r\n\r\n    const newPlacePromise = makeNewPlacePromise(id, this.consumer);\r\n    this.cache.set(id, newPlacePromise);\r\n    return newPlacePromise;\r\n  }\r\n\r\n  /**\r\n   * Adds the provided `Place` to the cache, replacing the existing `Place` if\r\n   * one exists already.\r\n   */\r\n  updatePlace(place: Place) {\r\n    this.cache.set(place.id, Promise.resolve(place));\r\n  }\r\n}\r\n"]}